<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
<!-- OneTrust Cookies Consent Notice start for xilinx.github.io -->

<script src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js" data-document-language="true" type="text/javascript" charset="UTF-8" data-domain-script="03af8d57-0a04-47a6-8f10-322fa00d8fc7" ></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice end for xilinx.github.io -->
  <title>Evaluating Software Performance &mdash; Embedded Design Tutorials 2021.2 documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link rel="next" title="Evaluating High-Performance Ports" href="6-evaluating-high-performance-ports.html" />
    <link rel="prev" title="Getting Started with SPM" href="4-getting-started-with-SPM.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
            <a href="../../../../index.html" class="icon icon-home"> Embedded Design Tutorials
            <img src="../../../../_static/xilinx-header-logo.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                2021.2
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">简体中文</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Embedded-Design-Tutorials/master/docs-cn/index.html">Master</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">日本語</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Embedded-Design-Tutorials/master/docs-jp/index.html">Master</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Introduction/Versal-EDT/Versal-EDT.html">Versal ACAP Embedded Design Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Introduction/ZynqMPSoC-EDT/ZynqMPSoC-EDT.html">Zynq UltraScale+ MPSoC Embedded Design Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Introduction/Zynq7000-EDT/Zynq7000-EDT.html">Zynq-7000 Embedded Design Tutorial</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Feature Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Feature_Tutorials/debuggable-fsbl/debuggable-fsbl.html">First Stage Boot Loader (FSBL)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Feature_Tutorials/sw-profiling/sw-profiling.html">Profiling Applications with System Debugger</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Design Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Design_Tutorials/MPSoC_Graphic_Subsystem/README.html">Example Setup for a Graphics and DisplayPort Based Sub-System</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Debugging</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Vitis-Embedded-Software-Debugging/Debugging.html">Vitis Embedded Software Debugging Guide (UG1515) 2021.1</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Guides</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../SPA-UG.html">System Performance Analysis</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="1-introduction.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="2-system-performance-modeling-project.html">System Performance Modeling Project</a></li>
<li class="toctree-l2"><a class="reference internal" href="3-monitor-framework.html">Monitor Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="4-getting-started-with-SPM.html">Getting Started with SPM</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Evaluating Software Performance</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#software-performance-monitoring">Software Performance Monitoring</a></li>
<li class="toctree-l3"><a class="reference internal" href="#visualizing-performance-improvements">Visualizing Performance Improvements</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="6-evaluating-high-performance-ports.html">Evaluating High-Performance Ports</a></li>
<li class="toctree-l2"><a class="reference internal" href="7-evaluating-DDR-controller-settings.html">Evaluating DDR Controller Settings</a></li>
<li class="toctree-l2"><a class="reference internal" href="8-evaluating-memory-hierarchy-ACP.html">Evaluating Memory Hierarchy and the ACP</a></li>
<li class="toctree-l2"><a class="reference internal" href="9-using-spa-with-custom-target.html">Using SPA with a Custom Target</a></li>
<li class="toctree-l2"><a class="reference internal" href="10-end-to-end-performance-analysis.html">End-To-End Performance Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="A-performance-checklist.html">Appendix: Performance Checklist</a></li>
<li class="toctree-l2"><a class="reference internal" href="../SPA-UG.html#requirements">Requirements</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../Performance_Benchmark/Dhrystone/README.html">Versal Dhrystone Benchmark</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Previous Releases</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Embedded-Design-Tutorials/docs/2021.1/build/html/index.html">2021.1</a></li>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Embedded-Design-Tutorials/docs/2020.2/build/html/index.html">2020.2</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: black" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">Embedded Design Tutorials</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../SPA-UG.html">System Performance Analysis</a> &raquo;</li>
      <li>Evaluating Software Performance</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../_sources/docs/User_Guides/SPA-UG/docs/5-evaluating-software-performance.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="evaluating-software-performance">
<h1>Evaluating Software Performance<a class="headerlink" href="#evaluating-software-performance" title="Permalink to this heading">¶</a></h1>
<p>There are a number of monitoring capabilities that evaluate software performance on a Zynq®-7000 SoC. These capabilities can inform you about the efficiency of your application and provide visualizations for you to better understand and optimize your software.</p>
<section id="software-performance-monitoring">
<h2>Software Performance Monitoring<a class="headerlink" href="#software-performance-monitoring" title="Permalink to this heading">¶</a></h2>
<p>To illustrate these performance monitoring capabilities, the BEEBS benchmark program (see <a class="reference internal" href="2-system-performance-modeling-project.html"><span class="doc">System Performance Modeling Project</span></a>) was run on a ZC702 target board and performance results were captured in the Vitis™ IDE. There was no traffic driven from the PL, so this is a software only test. Note that if you would like to re-create these results, the software application selection is
shown in <a class="reference internal" href="4-getting-started-with-SPM.html"><span class="doc">Getting Started with SPM</span></a>, and the PL traffic is shown in <a class="reference external" href="../docs/4-getting-started-with-SPM.md#atg-configuration">ATG Configuration</a>. Although the results shown here are for the BEEBS benchmarks, these exact same metrics can also be obtained for a program provided to or compiled by the Vitis IDE.</p>
<p>There are 24 total tests performed – each of the eight benchmarks listed in <a class="reference external" href="../docs/2-system-performance-modeling-project.md#table1">Table 1: BEEBS Benchmarks Provided in </a> is run on the three different data array sizes (that is, 4 KB, 64 KB, and 1024 KB). Because a sleep time of 1s was inserted between each test, the CPU utilization gives a clear view of when these benchmarks were run. The following figure helps orient the timeline for the results. The three data sizes were run from smallest to largest within each benchmark, which can be seen in the value and length of the utilization of CPU0. It took approximately 45s to run BEEBs benchmark without any traffic.</p>
<div id="fig13"><p><em>Figure 13:</em> <strong>CPU Utilization Labeled with BEEBS Benchmarks</strong></p>
<p><img alt="../../../../_images/image131.jpeg" src="../../../../_images/image131.jpeg" /></p>
<div><p>The following figure shows four different graphs displayed by the Vitis IDE in the PS Performance panel: CPU Utilization (%), CPU Instructions Per Cycle, L1 Data Cache Access, and L1 Data Cache Miss Rate (%).</p>
<p><em>Figure 14:</em> <strong>Performance Analysis of BEEBS Benchmarks - CPU Utilization, IPC, L1 Data Cache</strong></p>
<p><img alt="../../../../_images/image14.jpeg" src="../../../../_images/image14.jpeg" /></p>
<p>While CPU utilization helps determine when benchmarks were run, the most insightful analysis is achieved when multiple graphs are considered. For these particular tests, the significant analysis comes from the Instructions Per Cycle (IPC) and the L1 data cache graphs. IPC is a well-known metric to illustrate how software interacts with its environment, particularly the memory hierarchy. See Computer Organization &amp; Design: The Hardware/Software Interface by David A. Patterson and John L. Hennessy. This fact becomes evident in the previous figure as the value of IPC follows very closely the L1 data cache accesses. Also, during the memory-intensive matrix multipliers, the lowest values of IPC correspond with the highest values of L1 data cache miss rates. If IPC is a measure of software efficiency, then it is clear from the previous figure that the lowest efficiency is during long periods of memory-intensive computation. While sometimes this is unavoidable, it is clear that IPC provides a good metric for this interaction with the memory hierarchy.</p>
<p>Taking this analysis one step further, the graphs in the following figure provide information on data locality; that is, where the processor retrieves and writes data as it performs the specified algorithms. A low L1 data cache miss rate means that a significant amount of data is stored and accessed from that respective cache. A high L1 miss rate coupled with high values in CPU write or read stall cycles per instruction means that much of the data is coming from DDR. As expected, an understanding of the software application aids in the analysis. For example, the two long periods of high L1 miss rate and CPU read stall cycles shown in the following figure are when the floating-point and integer matrix multiplier algorithms are operating on the 512 x 512 (256K words = 1024 KB) two-dimensional or 2-D data array.</p>
<div id="fig15"><p><em>Figure 15:</em> <strong>Performance Analysis of BEEBS Benchmarks - L1 Data Cache, Stall Cycles Per Instruction</strong></p>
<p><img alt="../../../../_images/image15.jpeg" src="../../../../_images/image15.jpeg" /></p>
</div><p>To refine the performance of an application, one option to consider using is to enable/disable the L2 data cache prefetch. This is specified with bit 28 of reg15_prefetch_ctrl (absolute address 0xF8F02F60). If this data prefetching is enabled, then the adjacent cache line will also be automatically fetched. While the results shown in Figure 14 and Figure 15 were generated with prefetch enabled, the BEEBS benchmarks were also run with prefetch disabled. The integer matrix multiplication saw the largest impact on software run-time with a decrease of 9.0%. While this prefetch option can improve the performance of some applications, it can lower the performance of others. It is recommended to verify run-times of your application with and without this prefetch option.</p>
<p><em>Figure 16:</em> <strong>Run-Time Results of Software in BEEBS Benchmark Suite</strong></p>
<p><img alt="../../../../_images/image161.png" src="../../../../_images/image161.png" /></p>
<p>As mentioned above, a helpful measurement of overall software performance is the run-time of different portions of the application. The previous figure shows a summary of run times for the eight BEEBS benchmarks as run on the three different data array sizes (see <a class="reference external" href="../docs/9-using-spa-with-custom-target.md#instrumenting-hardware">Instrumenting Hardware</a> on how these run-times were calculated and captured). The Y-axis on the left side of the previous figure shows the full range of values, while the Y-axis on the right side zooms in on the lowest range for clarity. As expected, the run-times increase with larger array sizes. However, the amount of increase varies across the different benchmarks tested. This is because there are a number of different factors that can impact run-time, including the amount of data, data locality, and algorithmic dependencies on data size. As far as data locality, the 4 KB, 64 KB, and 1024 KB data arrays fit into the L1 data cache, L2 data cache, and DDR, respectively.</p>
<p>On the Zynq UltraScale+ MPSoC, the ZCU102 SPM project shows a similar result. The only difference difference is that the BEEBS benchmark does not use an interrupt between two tests, so the CPU utilization shows 100% all across the test time. However, you can see the same pattern of L1 data cache miss rate and CPU Read Stall Cycles per Instruction.</p>
<p><img alt="../../../../_images/spm_zcu102_swonly.png" src="../../../../_images/spm_zcu102_swonly.png" /></p>
<p>For more information on assessing the performance of the memory hierarchy, see <a class="reference internal" href="8-evaluating-memory-hierarchy-ACP.html"><span class="doc">Evaluating Memory Hierarchy and the ACP</span></a>.</p>
</section>
<section id="visualizing-performance-improvements">
<h2>Visualizing Performance Improvements<a class="headerlink" href="#visualizing-performance-improvements" title="Permalink to this heading">¶</a></h2>
<p>As shown in the previous figure, the longest run- times are clearly the matrix multiplications,especially for the largest array size. What if these run- times need to be improved? How would the performance analysis features in the Vitis IDE help measure and visualize any code optimizations or improvements?</p>
<p>The sample code below shows two different C/C++ implementations for floating-point matrix multiplication. The original and traditional implementation is the <code class="docutils literal notranslate"><span class="pre">Multiply_Old()</span></code> function, whereas a newer implementation is contained in <code class="docutils literal notranslate"><span class="pre">Multiply_New()</span></code>. While the newer implementation appears to be more complicated, it takes advantage of the 32 byte cache lines. See <a class="reference external" href="http://www.cs.bgu.ac.il/%7Eos142/wiki.files/drepper-2007.pdf">What Every Programmer Should Know About Memory</a> by Ulrich Drepper. The original and modified C/C++ software for floating-point matrix multiplication is as follows:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cp">#define CLS 32</span>
<span class="cp">#define SM	(CLS / sizeof (float))</span>
<span class="cm">/* Original method of calculating floating-point matrix multiplication */</span><span class="w"> </span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Multiply_Old</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">**</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">**</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">**</span><span class="n">Res</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">dim</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">dim</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">dim</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">Index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">Index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">dim</span><span class="p">;</span><span class="w"> </span><span class="n">Index</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="n">Res</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">Index</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">Index</span><span class="p">][</span><span class="n">j</span><span class="p">];</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="cm">/* Modified method of calculating floating-point matrix multiplication */</span><span class="w"> </span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Multiply_New</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">**</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">**</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">**</span><span class="n">Res</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">dim</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">dim</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">SM</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">dim</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">SM</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">dim</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">SM</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">rres</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Res</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">rmul1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">];</span><span class="w"></span>
<span class="w">                    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i2</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">SM</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i2</span><span class="p">,</span><span class="w"> </span><span class="n">rres</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">dim</span><span class="p">,</span><span class="w"> </span><span class="n">rmul1</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">dim</span><span class="p">)</span><span class="w"></span>
<span class="w">                    </span><span class="p">{</span><span class="w"></span>
<span class="w">                        </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">rmul2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span><span class="w"></span>
<span class="w">                        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">k2</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">SM</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">k2</span><span class="p">,</span><span class="w"> </span><span class="n">rmul2</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">dim</span><span class="p">)</span><span class="w"></span>
<span class="w">                        </span><span class="p">{</span><span class="w"></span>
<span class="w">                            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j2</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">SM</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j2</span><span class="p">)</span><span class="w"></span>
<span class="w">                            </span><span class="p">{</span><span class="w"></span>
<span class="w">                                </span><span class="n">rres</span><span class="p">[</span><span class="n">j2</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">rmul1</span><span class="p">[</span><span class="n">k2</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">rmul2</span><span class="p">[</span><span class="n">j2</span><span class="p">];</span><span class="w"></span>
</pre></div>
</div>
<p>The BEEBS benchmark software was re-compiled and re-run using the new implementations for both floating-point and integer matrix multiplications. The following table lists a summary of the performance metrics reported for CPU0 in the APU Performance Summary panel in the Vitis IDE. Even though only two of the eight benchmarks were modified, there was a noticeable difference in the reported metrics. The average IPC value increased by 34.9%, while there was a substantial drop in L1 data cache miss rate. The read stall cycles also decreased dramatically, revealing the reduction in clock cycles when the CPU is waiting on a data cache refill.</p>
<p><em>Table 5:</em> <strong>CPU0 Performance Summary with Original and Modified Matrix Multipliers</strong></p>
<table>
<thead>
<tr>
<th rowspan="2">Performance Metric</th>
<th colspan="3">CPU0 Performance Summary</th>
</tr>
<tr>
<th>Original</th>
<th>Modified</th>
<th>Changes</th>
</tr>
</thead>
<tbody>
<tr>
<td>CPU Utilization (%)</td>
<td>100.00</td>
<td>100.00</td>
<td><p>≈</p></td>
</tr>
<tr>
<td>CPU Instructions Per Cycle</td>
<td><p>0.43</p></td>
<td><p>0.58</p></td>
<td><p>↑</p>
</td>
</tr>
<tr>
<td>L1 Data Cache Miss Rate (%)</td>
<td><p>8.24</p></td>
<td><p>0.64</p></td>
<td><p>↓↓</p></td>
</tr>
<tr>
<td>L1 Data Cache Accesses</td>
<td><p>3484.33M</p></td>
<td>3653.48M</td><td>
<p>≈</p></td>
</tr>
<tr >
<td>CPU Write Stall Cycles Per Instruction</td>
<td><p>0.00</p></td>
<td><p>0.00</p></td>
<td><p>≈</p></td>
</tr>
<tr>
<td><p>CPU Read Stall Cycles Per Instruction</p></td>
<td><p>0.79</p></td>
<td><p>0.05</p></td>
<td><p>↓↓</p></td>
</tr>
</tbody>
</table><p>The following figure shows the L1 data cache graphs and CPU stall cycles per instruction reported in the PS Performance panel. In contrast to <a class="reference external" href="#fig15">Figure 15: Performance Analysis of BEEBS Benchmarks - L1 Data Cache, Stall Cycles Per Instruction</a>, it becomes clear that the bottlenecks of the code– the floating-point and integer matrix multiplications– have been dramatically improved. The long periods of low IPC, high L1 data cache miss rate, and high CPU read stall cycles toward the end of the capture have been shortened and improved considerably.</p>
<p><em>Figure 17:</em> <strong>Performance Analysis of BEEBS Benchmarks with Improved Matrix Multipliers</strong></p>
<p><img alt="../../../../_images/image17.jpeg" src="../../../../_images/image17.jpeg" /></p>
<p>This is confirmed with software run times. A summary of the measured run-times is also listed in the following table. The run-times of the floating-point and integer matrix multiplications were reduced to 22.8% and 17.0% of their original run-times, respectively.</p>
<p><em>Table 6:</em> <strong>Summary of Software Run-Times for Original and Modified Matrix Multipliers</strong></p>
<table>
<thead>
<th rowspan="2">Benchmark</th>
<th colspan="2">Software Run-Times (ms)</th>
</tr>
<tr>
<th>Original</th>
<th>Modified</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Floating-point matrix multiplication</td>
<td>
<p>9201.70</p>
</td>
<td>
<p>2100.36</p>
</td>
</tr>
<tr class="even">
<td></td>
<td>
<p>100.0%</p>
</td>
<td>
<p>22.8%</p>
</td>
</tr>
<tr class="odd">
<td>Integer matrix multiplication</td>
<td>
<p>8726.67</p>
</td>
<td>
<p>1483.24</p>
</td>
</tr>
<tr class="even">
<td></td>
<td>
<p>100.0%</p>
</td>
<td>
<p>17.0%</p>
</td>
</tr>
</tbody>
</table></section>
</section>


           </div>
          </div>
          
                  <style>
                        .footer {
                        position: fixed;
                        left: 0;
                        bottom: 0;
                        width: 100%;
                        }
                  </style>
				  
				  <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="4-getting-started-with-SPM.html" class="btn btn-neutral float-left" title="Getting Started with SPM" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="6-evaluating-high-performance-ports.html" class="btn btn-neutral float-right" title="Evaluating High-Performance Ports" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022, Xilinx, Inc. Xilinx is now a part of AMD.
      <span class="lastupdated">Last updated on August 1, 2022.
      </span></p>
  </div>



										<div class="aem-Grid aem-Grid--16">
											<div class="aem-GridColumn aem-GridColumn--xxxlarge--none aem-GridColumn--xsmall--16 aem-GridColumn--offset--xsmall--0 aem-GridColumn--xlarge--none aem-GridColumn--xxlarge--none aem-GridColumn--default--none aem-GridColumn--offset--large--1 aem-GridColumn--xlarge--12 aem-GridColumn--offset--default--0 aem-GridColumn--xxlarge--10 aem-GridColumn--offset--xlarge--2 aem-GridColumn--offset--xxlarge--3 aem-GridColumn--offset--xxxlarge--4 aem-GridColumn--xsmall--none aem-GridColumn--large--none aem-GridColumn aem-GridColumn--large--14 aem-GridColumn--xxxlarge--8 aem-GridColumn--default--16">
												<div class="container-fluid sub-footer">

													                    <div class="row">
                        <div class="col-xs-24">
                          <p><a target="_blank" href="https://www.amd.com/en/corporate/copyright">Terms and Conditions</a> | <a target="_blank" href="https://www.amd.com/en/corporate/privacy">Privacy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/cookies">Cookie Policy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/trademarks">Trademarks</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/statement-human-trafficking-forced-labor.pdf">Statement on Forced Labor</a> | <a target="_blank" href="https://www.amd.com/en/corporate/competition">Fair and Open Competition</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/amd-uk-tax-strategy.pdf">UK Tax Strategy</a> | <a target="_blank" href="https://docs.xilinx.com/v/u/9x6YvZKuWyhJId7y7RQQKA">Inclusive Terminology</a> | <a href="https://pages.gitenterprise.xilinx.com/techdocs/Test/vvas/build/html/index.html#cookiessettings" class="ot-sdk-show-settings">Cookies Settings</a></p>
                        </div>
                    </div>
												</div>
											</div>
										</div>
										
</br>


  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>