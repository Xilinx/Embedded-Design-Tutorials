<table class="sphinxhide">
 <tr>
   <td align="center"><img src="https://japan.xilinx.com/content/dam/xilinx/imgs/press/media-kits/corporate/xilinx-logo.png" width="30%"/><h1>2020.2 Vitis™ 入門チュートリアル</h1><a href="https://github.com/Xilinx/Vitis-Tutorials/tree/2020.1">2020.1 チュートリアルを参照</a></td>
 </tr>
 <tr>
 <td>
 </td>
 </tr>
</table>

# Vitis フロー 101 – パート 5: 結果の表示とレポートの解析

ここまでで vector-add の例をビルドして実行したので、次はその結果と生成されたレポートを見てみます。

## 実行サマリの保存場所

* アプリケーションを実行したディレクトリを見てみると、いくつかのファイルが生成されたことがわかります。

```
profile_summary.csv
timeline_trace.csv
vadd.xclbin.run_summary
```

>**注記**: ZCU102 ハードウェアをターゲットにした場合、これらのファイルは SD カードに保存されるため、この演習を続行するにはワークステーションにコピーし直す必要があります。

* これらのファイルおよびレポートの生成は、xrt.ini ファイルのランタイム オプションで制御されます。  このチュートリアルには、既存の xrt.ini ファイルが含まれており、プロファイル データと、次の内容を含む実行のタイムラインを生成できるようになっています。

```
[Debug]
profile=true
timeline_trace=true
```

## Vitis アナライザーで実行サマリを開く

この例は、3 つのビルド ターゲット (ソフトウェア エミュレーション、ハードウェア エミュレーション、およびハードウェア) すべての実行サマリを生成するように設定されています。これらの実行は、次の手順で解析できます。結果は、開いた結果によって異なります。ハードウェアの実行は完全に正確です。ハードウェア エミュレーションはサイクル概算シミュレーションで、ソフトウェア エミュレーションは機能を考慮するためにのみ使用します。また、U200 カードと ZCU102 カードの特性は異なるため、これら 2 つのターゲット間の結果は異なります。次は、U200 カードで実行されているハードウェアのスクリーンショットです。

* 解析する結果を含む実行ディレクトリから次のコマンドを実行します。

```bash
vitis_analyzer ./vadd.xclbin.run_summary
```

* Vitis アナライザーが開き、さまざまなレポートが読み込まれ、実行サマリが表示されます。Vitis アナライザーの左ペインを使用するか、実行サマリに表示されるリンクをクリックすると、さまざまなレポートを表示できます。
* システム ダイアグラムを開きます。
  * システム ダイアグラムは、ザイリンクス デバイスの内容をグラフィカルに表示したものです。さまざまなハードウェア アクセラレータと、グローバル メモリ バンクなどのプラットフォーム リソースへの接続方法を示しています。
  * vadd ハードウェア アクセラレータの横に表示されるプロファイル情報を確認します。
  * 図の右上にある \[Settings] アイコンをクリックし、\[Show Profile Info] チェック ボックスをオンにします。この図では、カーネル引数とカーネル ポートのマッピングが表示され、各ポートの帯域幅情報が示されています。
  * 図の下部にある 3 つのタブ (\[Compute Units]、\[Kernels]、\[Memories]) をクリックして、それぞれに表示される情報を確認します。
* 実行ガイダンス レポートを開きます。
  * ガイダンス レポートは、アプリケーションの最適ではないものにフラグを付け、改善方法に関する実用的なフィードバックを提供します。
  * このシンプルな例は完全には最適化されていないので、ガイダンス レポートには警告がいくつか表示されます。これらの警告をそれぞれ調べて、最適化の可能性や設計のベスト プラクティスなどの詳細を確認してください。
  * カーネル ポートの幅について何がわかりますか。
* プロファイル サマリ レポートを開きます。
  * プロファイル サマリには、全体的なアプリケーション パフォーマンスに関する注釈付きの詳細が表示されます。アプリケーションの実行中に生成されたすべてのデータが複数のカテゴリに分類されます。
  * レポートの左側のペインを使用して、さまざまなカテゴリを確認し、プロファイル サマリにレポートされたすべてのメトリックを確認します。
* アプリケーション タイムラインを開きます。
  * アプリケーション タイムラインは、ホストとカーネルのイベント情報を収集し、共通のタイムラインに表示します。これは、システムの全体的な状態とパフォーマンスを視覚的に表示するのに役立ちます。このグラフィカル表示により、カーネル同期および並列実行の効率に関する問題を確認しやすくなります。
  * タイムライン トレースを拡大して右端までスクロールし、ホスト プログラムがバッファーを転送し、カーネルを実行するポイントを表示します。
  * さまざまなアクティビティ イベントの上にマウスを置くと、それぞれのイベントの詳細が表示されます。
  * タイムライン アクティビティを `host.cpp` ファイル内の API 呼び出しのシーケンスに関連付けることができますか。

![img](./images/part5_timeline_trace.png)

* Vitis アナライザーでさまざまなレポートの確認が完了したら、ツールを閉じます。

## 宿題

これで、Vitis フローの基本を学習しましたので、ご自身で試してみてください。まずは、ホスト プログラムを変更してみることをお勧めします。`host.cpp` ファイルを変更するだけなら、FPGA バイナリをビルドし直す必要はありません。これにより、ビルドと実行の反復が非常に迅速になります。

* ホスト プログラムでは、ベクターのサイズは 4096 個のエレメントに (DATA\_SIZE マクロを使用して) ハード コード化されます。
  * このサイズを大きくするとどうなりますか。
  * Vitis アナライザーにはどう表示されますか。
* ホスト プログラムはアクセラレータを 1 回だけ呼び出します。
  * `host.cpp` のステップ 4 の周囲にループを配置して、さらに何回か繰り返した場合はどうなりますか。
  * アプリケーション タイムライン トレースはどのようになりますか。
  * プログラムがアクセラレータを呼び出すたびに、異なるベクターをアクセラレータに送信するようにできますか。

## まとめと次のステップ

これで、**Vitis フロー 101 チュートリアル**は終了です。コーディングの考慮事項やビルド、実行、レポートの表示方法など、Vitis プログラミングおよび実行モデルのすべての基本概念を理解できたはずです。

vector-add の例はシンプルですが、学ぶことが多いので、フローの重要な側面を深く掘り下げるのに非常に適したサンドボックスです。[Get Moving with Alveo チュートリアル](https://developer.xilinx.com/en/articles/acceleration-basics.html)では、同じ vector-add の例を活用し、一般的な最適化手法を説明することで、さらに手順をいくつか実行します。必ず確認してください。

[Vitis チュートリアル](https://github.com/Xilinx/Vitis-Tutorials)のホームページに戻ってください。

<p align="center"><sup>Copyright&copy; 2020 Xilinx</sup></p>
