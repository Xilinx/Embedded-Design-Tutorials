<p align="right"><a href="../../../../../../README.md">English</a> | <a>日本語</a></p>

**モジュール 3** のコード、ファイル、および手順 ([モジュール 1](../module1_baseline) と同じフローで GUI を設定または make を実行)

このモジュールでは、カーネル コードとホスト コードの両方を 64 ビット浮動小数点データ型 (double) ではなく、32 ビット浮動小数点データ型 (float) を使用するように変更し、データ型のサイズを下げることで、パフォーマンスおよび使用率がどれくらい改善されるかについて説明します。

U50 カードに搭載されているザイリンクス デバイスは、ハードウェア リソース (DSP ブロックおよびロジック) を使用して浮動小数点をインプリメント可能な UltraScale+ デバイスです。浮動小数点演算子は、多くのハードウェアを使用する傾向があります。このモジュールでは、32 ビットの浮動小数点型にサイズを下げた場合の節約量を測定します。

+ Vitis とハードウェア エミュレーションのみを実行します (モジュール 1 を参照)。  ソフトウェア エミュレーションや実際のハードウェア コンパイルを実行する必要はありません。
+ Vitis アナライザーを実行して、デバイス リソースへの影響とパフォーマンスの向上の両方を測定します。
+ 前のモジュールの使用率と比較してください。

カーネルの実行時間は短縮されましたか。

+ Vitis HLS を実行して、II を含む詳細なパラメーターを測定します (II は開始間隔であり、生成されたハードウェアは <II> クロック サイクルごとにデータを消費できます)。

リソースの使用率はモジュール 1 および 2 より少なくなっていますか。II は以前とは異なっていますか。

#### 使用されるカーネル リソース (通常の浮動小数点 vs 倍精度浮動小数点)

| 名前| LUT| LUTAsMem| REG| BRAM| DSP
|----------|----------:|----------:|----------:|----------:|----------:
| `double` を使用したカーネル| 10190| 799| 10,191| 514| 18
| `float` を使用したカーネル| 5,071| 746| 5,124| 258| 12

ロジックとストレージの両方すべてでリソース使用率が低下します。

- 32 ビット ワードを格納するので (doble データ型の場合は 64 ビットだった)、ストレージが約半分に減ります。
- また、演算子は消費するロジックが少ないため、DSP ブロックも少なくなります。

***


#### このモジュールのまとめ

データの精度を下げることで、パフォーマンスを向上させることができます。  ザイリンクス デバイスでは、データ型を簡素化することで、かなり結果が改善されます。

***


#### 次の手順

[**モジュール 4**](../module4_dataflow/README.md) に進みます。

***

<p align="center"><sup>Copyright&copy; 2020 Xilinx</sup></p>
<p align= center class="sphinxhide"><b><a href="../../../../../README.md">メイン ページに戻る</a> &mdash; <a href="../../../../README.md">ハードウェア アクセラレータ チュートリアルの初めに戻る</a></b></p></br>
<p align="center"><sup>この資料は 2021 年 2 月 8 日時点の表記バージョンの英語版を翻訳したもので、内容に相違が生じる場合には原文を優先します。資料によっては英語版の更新に対応していないものがあります。
日本語版は参考用としてご使用の上、最新情報につきましては、必ず最新英語版をご参照ください。</sup></p>
